require 'temppath/version'
require 'uuidtools'
require 'pathname'
require 'tmpdir'
require 'fileutils'

# Temppath creates temporary path. The differences from standard tempfile.rb are
# that this library generates Pathname objects with no files and filenames are
# based on UUID. Files in paths generated by this are deleted when Ruby exits.
#
# @example Create a temporary path
#   path = Temppath.create
#   #=> #<Pathname:/tmp/ruby-temppath-20130407-5775-w5k77l/f41bd6c5-fc99-4b7a-8f68-95b7ae4a6b22>
#   path.exist? #=> false
#   path.open("w")
#   "%o" % path.stat.mode #=> "100600" (default permission 0600)
# @example Touch a temporary file
#   path = Temppath.touch
#   path.file? #=> true
#   "%o" % path.stat.mode #=> "100600"
# @example Create a temporary directory
#   path = Temppath.mkdir
#   path.directory? #=> true
#   "%o" % path.stat.mode #=> "40700"
module Temppath
  # OriginalMethodHolder keeps some original methods of Pathname.
  module OriginalMethodHolder
    # @api private
    def self.extended(obj)
      # keep original methods
      obj.instance_exec do
        class << self
          alias :orig_open :open
          alias :orig_mkdir :mkdir
          alias :orig_mkpath :mkpath
          alias :orig_sysopen :sysopen
        end
      end
    end
  end

  # SecurePermissionMethods provides some Pathname methods with secure default
  # permission.
  module SecurePermissionMethods
    # Open file with permission 0600 by default. Otherwise, this is same as
    # Pathname#open.
    def open(*args, &b)
      args[1] = 0600 unless args[1]
      orig_open(*args, &b)
    end

    # Make a directory with permission 0700 by defautl. Otherwise, this is same
    # as Pathname#mkdir.
    def mkdir(*args)
      args[0] = 0700 unless args[0]
      orig_mkdir(*args)
    end

    # Make paths with permission 0700 by defautl. Otherwise, this is same as
    # Pathname#mkpath.
    def mkpath(*args)
      args[0] = {} unless args[0]
      args[0] = args[0].merge(mode: 0700) unless args[0][:mode]
      FileUtils.mkpath(self.to_s, *args)
    end

    # Open file with permission 0600 by default. Otherwise, this is same as
    # Pathname#sysopen.
    def sysopen(*args)
      args[1] = 0600 unless args[1]
      orig_sysopen(*args)
    end
  end

  class << self
    # @return [Pathname]
    #   defalut base directory for paths created by Temppath
    attr_reader :basedir

    # @return [Boolean]
    #   true if unlink mode is enabled
    attr_accessor :unlink

    # Create a temporary path. This method creates no files.
    #
    # @param option [Hash]
    # @option option [String] :basename
    #   prefix of filename
    # @option option [Pathname] :basedir
    #   pathname of base directory
    def create(option={})
      basename = option[:basename] || ""
      _basedir = option[:basedir] || basedir
      path = Pathname.new(_basedir) + (basename.to_s + generate_uuid)
      path.extend OriginalMethodHolder
      path.extend SecurePermissionMethods
      if _basedir != basedir
        Kernel.at_exit {FileUtils.remove_entry_secure(path) rescue Errno::ENOENT}
      end
      return path
    end

    # Create a temporary directory.
    def mkdir(option={})
      mode = option[:mode] || 0700
      path = create(option)
      path.mkdir(mode)
      return path
    end

    # Create a empty file.
    def touch(option={})
      mode = option[:mode] || 0600
      path = create(option)
      path.open("w", mode)
      return path
    end

    # Remove current base directory and change to use a new base directory.
    #
    # @param basedir [Pathname]
    #   new base directory, or nil
    # @return [Pathname]
    #   new base directory
    def update_basedir(basedir=nil)
      remove_basedir
      @basedir = basedir || create_basedir
    end

    # Remove current temporary directory.
    #
    # @return [void]
    def remove_basedir
      FileUtils.remove_entry_secure(@basedir) if @basedir.exist?
    end

    private

    # Create a new base directory.
    #
    # @return [Pathname]
    #   base directory
    def create_basedir
      Pathname.new(Dir.mktmpdir("ruby-temppath-"))
    end

    # Generate random UUID for filename of temporary path.
    #
    # @return [String]
    #   UUID string
    def generate_uuid
      UUIDTools::UUID.random_create.to_s
    end
  end

  @basedir = create_basedir
  @unlink = true
end

# Remove Temppath's temporary directory.
Kernel.at_exit do
  if Temppath.unlink
    Temppath.remove_basedir rescue Errno::ENOENT
  end
end
